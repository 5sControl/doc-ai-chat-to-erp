# Kokoro TTS Integration - Checklist для тестирования

## Версия библиотеки

- **kokoro_tts_flutter**: `0.2.0+1` (stable)
- **Причина использования стабильной версии**: Experimental версия 0.2.1-exp имеет проблемы с пустым lexicon и вызывает FormatException при фонетизации
- **Основные возможности**:
  - Поддержка int8 моделей для улучшения производительности
  - Стандартизированный формат аудио (float32)
  - Стабильная работа фонетизации

## Информация о модели

### Загружаемые файлы:
1. **model.onnx** - основная модель Kokoro TTS (~50-100 MB)
   - URL: `https://huggingface.co/NeuML/kokoro-base-onnx/resolve/main/model.onnx`
   - Альтернативный URL: `https://huggingface.co/NeuML/kokoro-base-onnx/raw/main/model.onnx`

2. **voices.json** - файл с голосами (~10-20 MB)
   - URL: `https://huggingface.co/NeuML/kokoro-base-onnx/resolve/main/voices.json`
   - Альтернативный URL: `https://huggingface.co/NeuML/kokoro-base-onnx/raw/main/voices.json`

3. **tokenizer_vocab.json** - файл словаря токенизатора для фонем (включен в assets проекта)
   - Расположение: `assets/tokenizer_vocab.json`
   - Назначение: Маппинг фонем и символов в числовые токены для токенизатора
   - Включен в проект: Да, файл создан и добавлен в `pubspec.yaml`

### Расположение файлов:
- **model.onnx и voices.json**: Сохраняются в `{AppDocuments}/tts_models/kokoro/` (загружаются автоматически)
- **tokenizer_vocab.json**: Включен в assets проекта (`assets/tokenizer_vocab.json`)
- Проверка наличия: автоматическая при выборе Kokoro TTS

## Что было исправлено и проверено

### ✅ Исправления:
1. **Имена файлов** - изменены с `kokoro-v1.0.onnx` и `voices-v1.0.bin` на `model.onnx` и `voices.json` (соответствует Hugging Face репозиторию)
2. **URL загрузки** - добавлены альтернативные URL на случай недоступности основных
3. **Обработка ошибок** - улучшена с проверкой размера файлов и верификацией сохранения
4. **Очистка временных файлов** - исправлена проблема с множественными слушателями в KokoroTtsEngine
5. **Прогресс загрузки** - исправлен (теперь правильно передается в диалог)
6. **tokenizer_vocab.json** - добавлен файл словаря токенизатора в assets проекта для корректной работы Kokoro TTS
7. **Улучшенная обработка ошибок** - добавлены проверки инициализации Kokoro и Tokenizer с понятными сообщениями об ошибках
8. **Обновление библиотеки** - обновлено до версии 0.2.1-exp для получения исправлений ошибок и улучшений

### ✅ Проверено:
- ✅ Все импорты корректны
- ✅ Нет ошибок линтера
- ✅ Структура файлов соответствует архитектуре
- ✅ Обработка ошибок добавлена на всех уровнях

## Чеклист для тестирования

### 1. Базовое тестирование
- [ ] Приложение компилируется без ошибок
- [ ] Настройки открываются без ошибок
- [ ] Секция TTS Settings отображается корректно

### 2. Тестирование выбора движка
- [ ] По умолчанию выбран "System TTS"
- [ ] При нажатии на "TTS Engine" открывается диалог выбора
- [ ] В диалоге отображаются оба варианта: System TTS и Kokoro TTS
- [ ] Выбор System TTS работает без изменений

### 3. Тестирование загрузки Kokoro модели
- [ ] При выборе Kokoro TTS открывается диалог загрузки
- [ ] Диалог показывает предупреждение "Не выключайте приложение"
- [ ] Прогресс-бар отображается и обновляется
- [ ] Процент загрузки отображается корректно (0% → 50% → 100%)
- [ ] После успешной загрузки диалог закрывается
- [ ] Движок переключается на Kokoro TTS

### 4. Тестирование работы Kokoro TTS
- [ ] После загрузки модели можно использовать Kokoro TTS
- [ ] Синтез речи работает (протестировать на английском тексте)
- [ ] Настройки скорости речи применяются
- [ ] Настройки громкости применяются
- [ ] Остановка воспроизведения работает
- [ ] Пауза работает (если поддерживается)

### 5. Тестирование переключения между движками
- [ ] Переключение с System на Kokoro работает
- [ ] Переключение с Kokoro на System работает
- [ ] Настройки (язык, скорость, громкость) сохраняются при переключении
- [ ] Текущий выбранный движок отображается в настройках

### 6. Тестирование повторной загрузки
- [ ] При повторном выборе Kokoro модель не загружается заново (если уже скачана)
- [ ] Проверка наличия модели работает корректно
- [ ] Если модель удалена вручную, она загружается снова

### 7. Тестирование ошибок
- [ ] При отсутствии интернета показывается понятное сообщение об ошибке
- [ ] При прерывании загрузки можно повторить попытку
- [ ] При ошибке загрузки диалог можно закрыть
- [ ] Приложение не крашится при ошибках

### 8. Тестирование на разных устройствах
- [ ] Android - работает корректно
- [ ] iOS - работает корректно (если поддерживается)
- [ ] Разные версии ОС

## Потенциальные проблемы и решения

### Проблема: Модель не загружается
**Решение:**
- Проверить интернет-соединение
- Проверить доступность Hugging Face
- Проверить логи на наличие ошибок загрузки
- Попробовать альтернативные URL

### Проблема: Kokoro TTS не инициализируется
**Решение:**
- Проверить, что файлы скачаны полностью (model.onnx и voices.json)
- Проверить, что tokenizer_vocab.json присутствует в assets и добавлен в pubspec.yaml
- Проверить права доступа к файлам
- Проверить логи на ошибки инициализации
- Убедиться, что все необходимые файлы загружены и доступны

### Проблема: Ошибка "Failed to load vocabulary from assets/tokenizer_vocab.json"
**Решение:**
- Убедиться, что файл `assets/tokenizer_vocab.json` существует
- Проверить, что файл добавлен в секцию `assets` в `pubspec.yaml`
- Выполнить `flutter clean` и `flutter pub get`
- Пересобрать приложение после добавления файла

### Проблема: Аудио не воспроизводится
**Решение:**
- Проверить настройки громкости устройства
- Проверить, что аудио файл создается корректно
- Проверить логи AudioPlayer

### Проблема: Большой размер модели
**Решение:**
- Модель ~50-100 MB, voices.json ~10-20 MB
- Убедиться, что на устройстве достаточно места
- Предупредить пользователя о размере перед загрузкой

## Дополнительные улучшения (опционально)

1. **Показ размера модели** перед загрузкой
2. **Проверка свободного места** на устройстве перед загрузкой
3. **Возможность удаления модели** из настроек
4. **Кэширование прогресса** загрузки для возможности возобновления
5. **Выбор голоса** для Kokoro TTS (сейчас используется 'af_heart' по умолчанию)

## Полезные ссылки

- **Hugging Face репозиторий модели**: https://huggingface.co/NeuML/kokoro-base-onnx
- **Hugging Face - Kokoro-82M-ONNX (техническая документация)**: https://huggingface.co/onnx-community/Kokoro-82M-ONNX
- **PyKokoro Documentation (Python библиотека)**: https://pykokoro.readthedocs.io/
- **Документация пакета Flutter**: https://pub.dev/packages/kokoro_tts_flutter
- **Версия пакета**: https://pub.dev/packages/kokoro_tts_flutter/versions/0.2.1-exp
- **GitHub репозиторий Kokoro**: https://github.com/NeonKokoro/kokoro

## Известные проблемы и решения

### Проблема: FormatException при инициализации
**Решение в версии 0.2.1-exp**: Исправлены ошибки парсинга JSON и улучшена обработка ошибок. Если проблема сохраняется, проверьте целостность файла voices.json и перезагрузите модель.

### Проблема: Ошибки с int8 моделями
**Решение в версии 0.2.1-exp**: Исправлена ошибка приведения типов для int8 моделей. Теперь можно использовать оптимизированные модели с флагом `isInt8: true` в KokoroConfig.

### Проблема: Ошибка "Text is too long, must be less than 510 phonemes"

**Техническое объяснение ограничения:**

Kokoro TTS имеет **контекстную длину модели 512 токенов**, но практический лимит для входного текста составляет **510 фонем**.

**Архитектура модели:**
- Контекстное окно: **512 токенов** (общая длина)
- Практический лимит: **510 фонем** для входного текста
- Резерв: **2 токена** для pad токенов (token 0) в начале и конце последовательности

**Форматирование токенов:**
Токены форматируются как `[0, *tokens, 0]`, что дает итоговую форму `(1, <=512)` после добавления padding.

**Источники:**
- **PyKokoro Documentation**: https://pykokoro.readthedocs.io/
  - Цитата: "Context length is 512, but leave room for the pad token 0 at the start & end"
  - Код: `assert len(tokens) <= 510`
- **Hugging Face - Kokoro-82M-ONNX**: https://huggingface.co/onnx-community/Kokoro-82M-ONNX
  - Техническая документация модели
  - Пример кода с проверкой `assert len(tokens) <= 510`

**Решение в нашем коде:**

В `TtsService.speak()` реализована автоматическая обрезка текста:

1. **Проверка длины фонем**: После фонемизации проверяется длина строки фонем
2. **Консервативный лимит**: Используется лимит **400 символов** (очень консервативно, так как библиотека считает фонемы не по длине строки)
3. **Многоуровневая обрезка**:
   - Первая попытка: обрезка до 400 символов
   - При ошибке: обрезка до 300 символов
   - При повторной ошибке: обрезка до 200 символов
4. **Обрезка по границам слов**: Текст обрезается по пробелам, чтобы не обрывать фонемы
5. **Уведомление пользователя**: Показывается сообщение "Text is too long. Only the first part is being played."

**Реализованное решение:**

В `lib/services/tts_service.dart`, метод `speak()`:

1. **Консервативные лимиты по длине строки**:
   - Библиотека считает фонемы не по длине строки символов, а по-другому
   - Используется очень консервативный подход: обрезка по длине строки
   - Первая попытка: **400 символов** (максимум)
   - Повторная попытка: **300 символов** (если первая не прошла)
   - Минимум: **200 символов** (абсолютный минимум)

2. **Многоуровневая обработка ошибок**:
   ```dart
   // Проверка длины перед синтезом
   if (phonemes.length > maxPhonemeChars) {
     truncatedPhonemes = phonemes.substring(0, maxPhonemeChars);
     // Обрезка по границам слов (пробелам)
     final lastSpace = truncatedPhonemes.lastIndexOf(' ');
     if (lastSpace > maxPhonemeChars * 0.7) {
       truncatedPhonemes = truncatedPhonemes.substring(0, lastSpace);
     }
     wasTruncated = true;
   }
   
   // При ошибке - более агрессивная обрезка
   catch (e) {
     if (e.toString().contains('510 phonemes')) {
       // Дальнейшая обрезка с уменьшением лимита
       // ...
     }
   }
   ```

3. **Уведомление пользователя**:
   - Используется `ValueNotifier<String?>` `textTruncationMessage`
   - При обрезке устанавливается сообщение
   - UI проверяет значение и показывает SnackBar

**Почему 400 символов, а не 510?**
- Библиотека считает фонемы не по длине строки символов
- Эмпирически установлено, что даже 667 символов вызывает ошибку
- 400 символов - очень консервативный лимит для надежности
- При ошибке выполняется более агрессивная обрезка до 300, затем до 200 символов

**Рекомендации для будущих улучшений:**
- Реализовать автоматическое разбиение текста на чанки по предложениям
- Добавить опцию для пользователя: "Разбить длинный текст автоматически"
- Можно попробовать более точный подсчет фонем по токенам (словам), а не по символам

**История решения проблемы:**

1. **Обнаружение проблемы**: При попытке синтезировать длинный текст возникала ошибка `Exception: Text is too long, must be less than 510 phonemes`

2. **Исследование**: 
   - Проверена документация библиотеки `kokoro_tts_flutter` - ограничение не было документировано
   - Найдена информация в PyKokoro документации и на Hugging Face о лимите в 510 фонем
   - Выяснено, что модель имеет контекстную длину 512 токенов, но 2 токена резервируются для padding

3. **Попытки решения**:
   - Первая попытка: обрезка до 510 символов - не сработала (библиотека считает фонемы не по длине строки)
   - Вторая попытка: обрезка до 500 символов - все еще ошибки
   - Третья попытка: эмпирическое тестирование показало, что даже 667 символов вызывает ошибку
   - Финальное решение: консервативный лимит в 400 символов с многоуровневой обработкой ошибок

4. **Реализация**:
   - Добавлена проверка длины фонем перед синтезом
   - Реализована обрезка по границам слов (пробелам) для сохранения целостности
   - Добавлена обработка ошибок с постепенным уменьшением лимита (400 → 300 → 200)
   - Реализовано уведомление пользователя через `ValueNotifier` и `SnackBar` в UI

5. **Результат**: 
   - Длинные тексты автоматически обрезаются до безопасного размера
   - Пользователь получает уведомление об обрезке
   - Воспроизводится хотя бы первая часть текста
   - Приложение не крашится при длинных текстах
